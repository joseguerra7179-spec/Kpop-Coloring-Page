<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Ppulbatu Coloring Book</title>
    <link rel="stylesheet" href="ppulbatu_css_interface.css">
    <link rel="icon" type="image/jpeg" href="favicon ppulbatu.jpg">
    <style>
        body { text-align: center; background-color: #333; }
        .controls { 
            background: rgba(255, 255, 255, 0.9); 
            padding: 15px; 
            border-radius: 10px; 
            display: inline-block; 
            margin-bottom: 10px;
        }
        canvas { border: 2px solid #000; cursor: crosshair; max-width: 90vw; }
        .active { border: 2px solid #c7127c; background-color: #ffcceb; }
    </style>
</head>
<body>

    <h2 style="font-family: sans-serif; color: white; text-shadow: 2px 2px 0 #000; font-size: 50px; margin: 10px;">
        COLORING K-POP KAWAII MASCOTS
    </h2>
    
    <div class="controls">
        <label>Color:</label>
        <input type="color" id="colorPicker" value="#ff0000">

        <label>Tools:</label>
        <button id="btnBrush" onclick="setTool('brush')" class="active">Brush üñåÔ∏è</button>
        <button id="btnBucket" onclick="setTool('bucket')">Color Bucket</button>

        <label>Brush Size:</label>
        <input type="range" id="brushSize" min="1" max="50" value="10">

        <button onclick="resetCanvas()" style="margin-left: 20px;">Delete all color üóëÔ∏è</button>
        <button onclick="saveCanvas()" style="margin-left: 10px; background-color: #4CAF50; color: white;">Save Drawing üíæ</button>
    </div>

    <br>
    <canvas id="paintCanvas"></canvas>

    <script>
        const canvas = document.getElementById('paintCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const colorPicker = document.getElementById('colorPicker');
        const brushSize = document.getElementById('brushSize');
        
        let img = new Image();
        // Canvas invisible para guardar SOLO las l√≠neas
        let lineArtCanvas = document.createElement('canvas'); 
        let lineArtCtx = lineArtCanvas.getContext('2d');

        let currentTool = 'brush'; 
        let painting = false;

        img.crossOrigin = "Anonymous"; 
        img.src = 'Gemini_Generated_Image_z1irbiz1irbiz1ir.png'; 

       img.onload = () => {
    // Definimos un tama√±o m√°ximo deseado (ej. 800px)
    const MAX_WIDTH = 800;
    const MAX_HEIGHT = 600;
    
    let width = img.width;
    let height = img.height;

    // L√≥gica para encoger la imagen si es muy grande manteniendo proporci√≥n
    if (width > MAX_WIDTH) {
        height *= MAX_WIDTH / width;
        width = MAX_WIDTH;
    }
    if (height > MAX_HEIGHT) {
        width *= MAX_HEIGHT / height;
        height = MAX_HEIGHT;
    }

    canvas.width = width;
    canvas.height = height;
    
    // El canvas de l√≠neas debe tener el mismo tama√±o exacto
    lineArtCanvas.width = width;
    lineArtCanvas.height = height;
    
    // Dibujamos la imagen reescalada en el canvas de l√≠neas
    lineArtCtx.drawImage(img, 0, 0, width, height);
    
    // PROCESO: Convertir lo blanco en transparente
    let imageData = lineArtCtx.getImageData(0, 0, width, height);
    let data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
        if (data[i] > 200 && data[i+1] > 200 && data[i+2] > 200) {
            data[i+3] = 0; 
        }
    }
    lineArtCtx.putImageData(imageData, 0, 0);

    resetCanvas();
};

        function setTool(tool) {
            currentTool = tool;
            document.getElementById('btnBrush').classList.toggle('active', tool === 'brush');
            document.getElementById('btnBucket').classList.toggle('active', tool === 'bucket');
        }

        function resetCanvas() {
            // Rellenar de blanco puro
            ctx.fillStyle = "white";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Poner las l√≠neas encima
            ctx.drawImage(lineArtCanvas, 0, 0);
        }

        function saveCanvas() {
            const link = document.createElement('a');
            link.download = 'mi_dibujo_ppulbatu.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // --- DIBUJAR LAS L√çNEAS ENCIMA (Funci√≥n Clave) ---
        function restoreLines() {
            // Simplemente estampamos el canvas transparente con las l√≠neas negras encima de todo
            ctx.drawImage(lineArtCanvas, 0, 0);
        }

        // --- L√ìGICA DE DIBUJO ---

        canvas.addEventListener('mousedown', startPosition);
        canvas.addEventListener('mouseup', finishedPosition);
        canvas.addEventListener('mousemove', draw);

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: Math.floor((e.clientX - rect.left) * scaleX),
                y: Math.floor((e.clientY - rect.top) * scaleY)
            };
        }

        function startPosition(e) {
            const pos = getMousePos(e);
            if (currentTool === 'bucket') {
                handleFloodFill(pos.x, pos.y);
            } else {
                painting = true;
                draw(e);
            }
        }

        function finishedPosition() {
            painting = false;
            ctx.beginPath();
        }

        function draw(e) {
            if (!painting || currentTool !== 'brush') return;

            const pos = getMousePos(e);
            
            ctx.lineWidth = brushSize.value;
            ctx.lineCap = 'round';
            ctx.strokeStyle = colorPicker.value;

            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);

            // ARREGLO 1: Inmediatamente despu√©s de pintar, volvemos a poner las l√≠neas encima.
            // Esto asegura que NUNCA pintes sobre la l√≠nea negra.
            restoreLines();
        }

      // --- L√ìGICA DE BOTE DE PINTURA (FLOOD FILL) ---

        function handleFloodFill(startX, startY) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            // IMPORTANTE: Obtenemos tambi√©n los datos de las l√≠neas
            const lineArtData = lineArtCtx.getImageData(0, 0, canvas.width, canvas.height).data;
            
            const fillColor = hexToRgb(colorPicker.value);
            const targetColor = getPixel(imageData, startX, startY);

            // Evitar bucle infinito si es el mismo color
            if (isSameColor(targetColor, fillColor)) return;

            // Pasamos 'lineArtData' a la funci√≥n
            floodFill(imageData, lineArtData, startX, startY, fillColor, targetColor);
            
            // Aplicar cambios
            ctx.putImageData(imageData, 0, 0);
            
            // Restaurar l√≠neas inmediatamente (para asegurar visualizaci√≥n n√≠tida)
            restoreLines();
        }

        function floodFill(imageData, lineArtData, startX, startY, fillColor, targetColor) {
            const data = imageData.data;
            const stack = [[startX, startY]];
            const width = imageData.width;
            const height = imageData.height;
            // Usamos Uint8Array para marcar visitados (m√°s eficiente)
            const visited = new Uint8Array(width * height);

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const pixelIndex = y * width + x;
                const offset = pixelIndex * 4;

                if (x < 0 || x >= width || y < 0 || y >= height || visited[pixelIndex]) continue;

                // --- CORRECCI√ìN DEL BUG ---
                // Verificamos si en esta posici√≥n hay una L√çNEA en el canvas de l√≠neas.
                // En tu c√≥digo de carga, hiciste transparentes los blancos. 
                // Por lo tanto, si el canal Alpha (offset+3) es alto (> 50), es una l√≠nea s√≥lida.
                // Si es una l√≠nea, la tratamos como un muro y paramos, no pintamos.
                if (lineArtData[offset + 3] > 50) {
                    continue; 
                }
                // --------------------------

                visited[pixelIndex] = 1;

                const r = data[offset];
                const g = data[offset + 1];
                const b = data[offset + 2];

                // Comparamos si es el color que queremos reemplazar
                if (Math.abs(r - targetColor.r) < 50 && 
                    Math.abs(g - targetColor.g) < 50 && 
                    Math.abs(b - targetColor.b) < 50) {
                    
                    // Pintamos
                    data[offset] = fillColor.r;
                    data[offset + 1] = fillColor.g;
                    data[offset + 2] = fillColor.b;
                    data[offset + 3] = 255;
                    
                    stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
                }
            }
        }

        // --- UTILIDADES ---

        function getPixel(imageData, x, y) {
            const offset = (y * imageData.width + x) * 4;
            return {
                r: imageData.data[offset],
                g: imageData.data[offset + 1],
                b: imageData.data[offset + 2]
            };
        }

        function isSameColor(c1, c2) {
            return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b;
        }

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return { r, g, b };
        }
    </script>
</body>
</html>